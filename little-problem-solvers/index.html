
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little Problem Solvers</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #FF6B6B;
            --secondary: #4ECDC4;
            --tertiary: #FFE66D;
            --background: #F7FFF7;
            --dark: #292F36;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        
        body {
            background-color: var(--background);
            color: var(--dark);
            overflow-x: hidden;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        /* Main Menu */
        .main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 600px;
        }
        
        .character {
            width: 150px;
            height: 150px;
            background-color: var(--secondary);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            animation: bounce 2s infinite;
        }
        
        .character i {
            font-size: 80px;
            color: white;
        }
        
        .menu-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 100%;
        }
        
        .btn {
            background-color: var(--tertiary);
            color: var(--dark);
            border: none;
            border-radius: 30px;
            padding: 20px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        
        .btn i {
            font-size: 2.5rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 15px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background-color: var(--secondary);
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
        }
        
        /* Game Screens */
        .game-screen {
            display: none;
            width: 100%;
            max-width: 600px;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }
        
        .back-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .score-display {
            background-color: var(--tertiary);
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        /* Matching Game */
        .matching-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
        }
        
        .card {
            aspect-ratio: 1/1;
            background-color: var(--primary);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            transform-style: preserve-3d;
            transform: rotateY(180deg);
            transition: transform 0.5s;
            position: relative;
        }
        
        .card.show {
            transform: rotateY(0deg);
        }
        
        .card.found {
            background-color: var(--secondary);
            cursor: default;
        }
        
        /* Maze Game */
        .maze-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1/1;
            background-color: #f0f0f0;
            border: 3px solid var(--dark);
        }
        
        .maze {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
        }
        
        .player {
            position: absolute;
            width: 10%;
            height: 10%;
            background-color: var(--primary);
            border-radius: 50%;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .wall {
            position: absolute;
            background-color: var(--dark);
        }
        
        .exit {
            position: absolute;
            width: 10%;
            height: 10%;
            background-color: var(--secondary);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .exit i {
            font-size: 1.5rem;
            color: white;
        }
        
        /* Puzzle Game */
        .puzzle-container {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1/1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            position: relative;
        }
        
        .puzzle-piece {
            background-color: var(--primary);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .puzzle-piece.empty {
            background-color: transparent;
            border: 2px dashed var(--dark);
            cursor: default;
        }
        
        /* Animation */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: var(--primary);
            opacity: 0;
            animation: confetti 2s ease-out;
            z-index: 100;
        }
        
        @keyframes confetti {
            0% { transform: translateY(0) rotate(0); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            .menu-buttons {
                grid-template-columns: 1fr;
            }
            
            .matching-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Little Problem Solvers</h1>
    </header>
    
    <div class="container">
        <!-- Main Menu -->
        <div class="main-menu" id="mainMenu">
            <div class="character">
                <i class="fas fa-child"></i>
            </div>
            
            <h2>Let's Play!</h2>
            
            <div class="menu-buttons">
                <button class="btn" onclick="startGame('matching')">
                    <i class="fas fa-images"></i>
                    Matching
                </button>
                <button class="btn" onclick="startGame('maze')">
                    <i class="fas fa-project-diagram"></i>
                    Maze
                </button>
                <button class="btn" onclick="startGame('puzzle')">
                    <i class="fas fa-puzzle-piece"></i>
                    Puzzle
                </button>
                <button class="btn" onclick="showProgress()">
                    <i class="fas fa-trophy"></i>
                    My Progress
                </button>
            </div>
            
            <div class="progress-bar">
                <div class="progress" id="progress">0%</div>
            </div>
        </div>
        
        <!-- Matching Game -->
        <div class="game-screen" id="matchingGame">
            <div class="game-header">
                <button class="back-btn" onclick="returnToMenu()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="score-display">
                    <i class="fas fa-star"></i>
                    <span id="matchingScore">0</span>
                </div>
            </div>
            
            <h2>Match the Pictures!</h2>
            <p>Find all the matching pairs</p>
            
            <div class="matching-grid" id="matchingGrid"></div>
        </div>
        
        <!-- Maze Game -->
        <div class="game-screen" id="mazeGame">
            <div class="game-header">
                <button class="back-btn" onclick="returnToMenu()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="score-display">
                    <i class="fas fa-star"></i>
                    <span id="mazeScore">0</span>
                </div>
            </div>
            
            <h2>Find Your Way!</h2>
            <p>Guide the red dot to the green exit</p>
            
            <div class="maze-container">
                <div class="maze" id="maze">
                    <div class="player" id="player"></div>
                    <div class="exit" id="exit"><i class="fas fa-flag"></i></div>
                </div>
            </div>
        </div>
        
        <!-- Puzzle Game -->
        <div class="game-screen" id="puzzleGame">
            <div class="game-header">
                <button class="back-btn" onclick="returnToMenu()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="score-display">
                    <i class="fas fa-star"></i>
                    <span id="puzzleScore">0</span>
                </div>
            </div>
            
            <h2>Solve the Puzzle!</h2>
            <p>Put the pieces in the right order</p>
            
            <div class="puzzle-container" id="puzzleContainer"></div>
        </div>
    </div>
    
    <audio id="correctSound" src="https://assets.mixkit.co/active_storage/sfx/2577/2577-preview.mp3"></audio>
    <audio id="winSound" src="https://assets.mixkit.co/active_storage/sfx/2426/2426-preview.mp3"></audio>
    <audio id="clickSound" src="https://assets.mixkit.co/active_storage/sfx/499/499-preview.mp3"></audio>
    
    <script>
        // Game state
        const gameState = {
            progress: 0,
            matching: {
                score: 0,
                level: 1
            },
            maze: {
                score: 0,
                level: 1
            },
            puzzle: {
                score: 0,
                level: 1
            }
        };
        
        // DOM Elements
        const mainMenu = document.getElementById('mainMenu');
        const matchingGame = document.getElementById('matchingGame');
        const mazeGame = document.getElementById('mazeGame');
        const puzzleGame = document.getElementById('puzzleGame');
        const progressBar = document.getElementById('progress');
        
        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            updateProgress();
            
            // Preload sounds
            const sounds = ['correctSound', 'winSound', 'clickSound'];
            sounds.forEach(sound => {
                document.getElementById(sound).volume = 0.3;
            });
        });
        
        // Game navigation
        function startGame(game) {
            playSound('clickSound');
            
            mainMenu.style.display = 'none';
            
            switch(game) {
                case 'matching':
                    matchingGame.style.display = 'flex';
                    initMatchingGame();
                    break;
                case 'maze':
                    mazeGame.style.display = 'flex';
                    initMazeGame();
                    break;
                case 'puzzle':
                    puzzleGame.style.display = 'flex';
                    initPuzzleGame();
                    break;
            }
        }
        
        function returnToMenu() {
            playSound('clickSound');
            
            matchingGame.style.display = 'none';
            mazeGame.style.display = 'none';
            puzzleGame.style.display = 'none';
            
            mainMenu.style.display = 'flex';
            updateProgress();
        }
        
        function showProgress() {
            playSound('clickSound');
            alert(`Your current progress: ${gameState.progress}%\n\nMatching: Level ${gameState.matching.level}\nMaze: Level ${gameState.maze.level}\nPuzzle: Level ${gameState.puzzle.level}`);
        }
        
        // Progress tracking
        function updateProgress() {
            const total = (gameState.matching.score + gameState.maze.score + gameState.puzzle.score);
            gameState.progress = Math.min(Math.floor(total / 3), 100);
            progressBar.style.width = `${gameState.progress}%`;
            progressBar.textContent = `${gameState.progress}%`;
        }
        
        function addProgress(points, game) {
            gameState[game].score += points;
            document.getElementById(`${game}Score`).textContent = gameState[game].score;
            
            // Level up every 10 points
            if (gameState[game].score >= gameState[game].level * 10) {
                gameState[game].level++;
                celebrate();
                setTimeout(() => {
                    alert(`Level Up! Now at level ${gameState[game].level}`);
                    playSound('winSound');
                }, 1000);
            }
            
            updateProgress();
        }
        
        // Audio functions
        function playSound(soundId) {
            const sound = document.getElementById(soundId);
            sound.currentTime = 0;
            sound.play();
        }
        
        // Visual effects
        function celebrate() {
            for (let i = 0; i < 50; i++) {
                createConfetti();
            }
        }
        
        function createConfetti() {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
            confetti.style.width = `${Math.random() * 10 + 5}px`;
            confetti.style.height = `${Math.random() * 10 + 5}px`;
            document.body.appendChild(confetti);
            
            setTimeout(() => {
                confetti.remove();
            }, 2000);
        }
        
        // Matching Game Logic
        function initMatchingGame() {
            const grid = document.getElementById('matchingGrid');
            grid.innerHTML = '';
            
            const level = gameState.matching.level;
            const pairs = Math.min(4 + Math.floor(level / 2), 8);
            const icons = ['cat', 'dog', 'frog', 'fish', 'car', 'bus', 'apple', 'lemon', 'house', 'tree', 'sun', 'cloud'];
            const selectedIcons = icons.slice(0, pairs).flatMap(icon => [icon, icon]);
            
            // Shuffle
            for (let i = selectedIcons.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [selectedIcons[i], selectedIcons[j]] = [selectedIcons[j], selectedIcons[i]];
            }
            
            // Create cards
            let flippedCards = [];
            let canFlip = true;
            
            selectedIcons.forEach((icon, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.index = index;
                card.dataset.icon = icon;
                
                card.innerHTML = `<i class="fas fa-${icon}"></i>`;
                
                card.addEventListener('click', () => {
                    if (!canFlip || card.classList.contains('show') || card.classList.contains('found')) return;
                    
                    playSound('clickSound');
                    card.classList.add('show');
                    flippedCards.push(card);
                    
                    if (flippedCards.length === 2) {
                        canFlip = false;
                        
                        if (flippedCards[0].dataset.icon === flippedCards[1].dataset.icon) {
                            // Match found
                            setTimeout(() => {
                                flippedCards.forEach(c => c.classList.add('found'));
                                playSound('correctSound');
                                addProgress(1, 'matching');
                                flippedCards = [];
                                canFlip = true;
                                
                                // Check if all cards are found
                                if (document.querySelectorAll('.card.found').length === selectedIcons.length) {
                                    celebrate();
                                    setTimeout(() => {
                                        alert('Great job! You found all the matches!');
                                        returnToMenu();
                                    }, 1000);
                                }
                            }, 500);
                        } else {
                            // No match
                            setTimeout(() => {
                                flippedCards.forEach(c => c.classList.remove('show'));
                                playSound('clickSound');
                                flippedCards = [];
                                canFlip = true;
                            }, 1000);
                        }
                    }
                });
                
                grid.appendChild(card);
                
                // Show cards briefly at start
                setTimeout(() => {
                    card.classList.add('show');
                }, 500 + index * 100);
                
                setTimeout(() => {
                    card.classList.remove('show');
                }, 2500 + index * 100);
            });
        }
        
        // Maze Game Logic
        function initMazeGame() {
            const maze = document.getElementById('maze');
            const player = document.getElementById('player');
            const exit = document.getElementById('exit');
            
            // Clear previous walls
            document.querySelectorAll('.wall').forEach(wall => wall.remove());
            
            const level = gameState.maze.level;
            const size = Math.min(5 + Math.floor(level / 2), 10);
            const cellSize = 100 / size;
            
            // Generate maze
            const walls = generateMaze(size);
            
            // Position player and exit
            player.style.width = `${cellSize}%`;
            player.style.height = `${cellSize}%`;
            player.style.top = '5%';
            player.style.left = '5%';
            
            exit.style.width = `${cellSize}%`;
            exit.style.height = `${cellSize}%`;
            exit.style.top = `${95 - cellSize}%`;
            exit.style.left = `${95 - cellSize}%`;
            
            // Create walls
            walls.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (cell.right) {
                        const wall = document.createElement('div');
                        wall.className = 'wall';
                        wall.style.width = '2%';
                        wall.style.height = `${cellSize}%`;
                        wall.style.top = `${i * cellSize}%`;
                        wall.style.left = `${(j + 1) * cellSize}%`;
                        maze.appendChild(wall);
                    }
                    
                    if (cell.bottom) {
                        const wall = document.createElement('div');
                        wall.className = 'wall';
                        wall.style.width = `${cellSize}%`;
                        wall.style.height = '2%';
                        wall.style.top = `${(i + 1) * cellSize}%`;
                        wall.style.left = `${j * cellSize}%`;
                        maze.appendChild(wall);
                    }
                });
            });
            
            // Add border walls
            ['top', 'right', 'bottom', 'left'].forEach(side => {
                const wall = document.createElement('div');
                wall.className = 'wall';
                
                if (side === 'top' || side === 'bottom') {
                    wall.style.width = '100%';
                    wall.style.height = '2%';
                    wall.style.left = '0';
                    wall.style[side] = '0';
                } else {
                    wall.style.width = '2%';
                    wall.style.height = '100%';
                    wall.style.top = '0';
                    wall.style[side] = '0';
                }
                
                maze.appendChild(wall);
            });
            
            // Player movement
            let playerPos = { x: 0, y: 0 };
            let isDragging = false;
            let startX, startY;
            
            player.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                const mazeRect = maze.getBoundingClientRect();
                const playerWidth = player.clientWidth;
                const playerHeight = player.clientHeight;
                
                let newLeft = parseFloat(player.style.left) + (dx / mazeRect.width) * 100;
                let newTop = parseFloat(player.style.top) + (dy / mazeRect.height) * 100;
                
                // Boundary checks
                newLeft = Math.max(0, Math.min(100 - (playerWidth / mazeRect.width) * 100, newLeft));
                newTop = Math.max(0, Math.min(100 - (playerHeight / mazeRect.height) * 100, newTop));
                
                // Collision detection with walls (simplified for this example)
                // In a full implementation, you would check for precise collision with each wall
                
                player.style.left = `${newLeft}%`;
                player.style.top = `${newTop}%`;
                
                startX = e.clientX;
                startY = e.clientY;
                
                // Check if reached exit
                const exitRect = exit.getBoundingClientRect();
                const playerRect = player.getBoundingClientRect();
                
                if (
                    playerRect.left < exitRect.right &&
                    playerRect.right > exitRect.left &&
                    playerRect.top < exitRect.bottom &&
                    playerRect.bottom > exitRect.top
                ) {
                    // Reached exit
                    playSound('winSound');
                    celebrate();
                    addProgress(1, 'maze');
                    
                    setTimeout(() => {
                        alert('You found the exit! Great job!');
                        returnToMenu();
                    }, 1000);
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Touch support
            player.addEventListener('touchstart', (e) => {
                isDragging = true;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;
                
                const mazeRect = maze.getBoundingClientRect();
                const playerWidth = player.clientWidth;
                const playerHeight = player.clientHeight;
                
                let newLeft = parseFloat(player.style.left) + (dx / mazeRect.width) * 100;
                let newTop = parseFloat(player.style.top) + (dy / mazeRect.height) * 100;
                
                // Boundary checks
                newLeft = Math.max(0, Math.min(100 - (playerWidth / mazeRect.width) * 100, newLeft));
                newTop = Math.max(0, Math.min(100 - (playerHeight / mazeRect.height) * 100, newTop));
                
                player.style.left = `${newLeft}%`;
                player.style.top = `${newTop}%`;
                
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                
                // Check if reached exit (same as above)
                const exitRect = exit.getBoundingClientRect();
                const playerRect = player.getBoundingClientRect();
                
                if (
                    playerRect.left < exitRect.right &&
                    playerRect.right > exitRect.left &&
                    playerRect.top < exitRect.bottom &&
                    playerRect.bottom > exitRect.top
                ) {
                    // Reached exit
                    playSound('winSound');
                    celebrate();
                    addProgress(1, 'maze');
                    
                    setTimeout(() => {
                        alert('You found the exit! Great job!');
                        returnToMenu();
                    }, 1000);
                }
                
                e.preventDefault();
            });
            
            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        }
        
        // Simplified maze generation (Prim's algorithm)
        function generateMaze(size) {
            const grid = Array(size).fill().map(() => Array(size).fill().map(() => ({
                right: true,
                bottom: true,
                visited: false
            })));
            
            // Start with random cell
            const stack = [{ x: 0, y: 0 }];
            grid[0][0].visited = true;
            
            while (stack.length) {
                const current = stack.pop();
                const { x, y } = current;
                
                const neighbors = [];
                
                if (x > 0 && !grid[x-1][y].visited) neighbors.push({ x: x-1, y, direction: 'top' });
                if (x < size-1 && !grid[x+1][y].visited) neighbors.push({ x: x+1, y, direction: 'bottom' });
                if (y > 0 && !grid[x][y-1].visited) neighbors.push({ x, y: y-1, direction: 'left' });
                if (y < size-1 && !grid[x][y+1].visited) neighbors.push({ x, y: y+1, direction: 'right' });
                
                if (neighbors.length) {
                    stack.push(current);
                    
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const { x: nx, y: ny, direction } = next;
                    
                    if (direction === 'top') grid[x-1][y].bottom = false;
                    if (direction === 'bottom') grid[x][y].bottom = false;
                    if (direction === 'left') grid[x][y-1].right = false;
                    if (direction === 'right') grid[x][y].right = false;
                    
                    grid[nx][ny].visited = true;
                    stack.push({ x: nx, y: ny });
                }
            }
            
            return grid;
        }
        
        // Puzzle Game Logic
        function initPuzzleGame() {
            const container = document.getElementById('puzzleContainer');
            container.innerHTML = '';
            
            const level = gameState.puzzle.level;
            const size = Math.min(3 + Math.floor(level / 3), 5);
            
            // Create a solved puzzle
            const numbers = Array.from({ length: size * size - 1 }, (_, i) => i + 1);
            
            // Shuffle until solvable
            let puzzle;
            do {
                const shuffled = [...numbers];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                puzzle = shuffled.concat([0]);
            } while (!isSolvable(puzzle, size));
            
            // Create puzzle pieces
            const tileSize = 100 / size;
            
            for (let i = 0; i < size * size; i++) {
                const piece = document.createElement('div');
                piece.className = puzzle[i] === 0 ? 'puzzle-piece empty' : 'puzzle-piece';
                
                if (puzzle[i] !== 0) {
                    piece.textContent = puzzle[i];
                }
                
                piece.dataset.value = puzzle[i];
                piece.dataset.index = i;
                
                piece.style.width = `calc(${tileSize}% - 5px)`;
                piece.style.height = `calc(${tileSize}% - 5px)`;
                
                piece.addEventListener('click', () => {
                    if (piece.classList.contains('empty')) return;
                    
                    const emptyIndex = Array.from(container.children).findIndex(child => 
                        child.classList.contains('empty')
                    );
                    
                    const clickedIndex = Array.from(container.children).indexOf(piece);
                    
                    const emptyRow = Math.floor(emptyIndex / size);
                    const emptyCol = emptyIndex % size;
                    const clickedRow = Math.floor(clickedIndex / size);
                    const clickedCol = clickedIndex % size;
                    
                    // Check if adjacent (up, down, left, right)
                    if (
                        (Math.abs(emptyRow - clickedRow) === 1 && emptyCol === clickedCol) ||
                        (Math.abs(emptyCol - clickedCol) === 1 && emptyRow === clickedRow)
                    ) {
                        playSound('clickSound');
                        
                        // Swap
                        const emptyPiece = container.children[emptyIndex];
                        
                        // Update display
                        emptyPiece.textContent = piece.textContent;
                        emptyPiece.classList.remove('empty');
                        emptyPiece.dataset.value = piece.dataset.value;
                        
                        piece.textContent = '';
                        piece.classList.add('empty');
                        piece.dataset.value = '0';
                        
                        // Check if solved
                        if (isSolved(container, size)) {
                            playSound('winSound');
                            celebrate();
                            addProgress(1, 'puzzle');
                            
                            setTimeout(() => {
                                alert('Puzzle solved! You\'re amazing!');
                                returnToMenu();
                            }, 1000);
                        }
                    }
                });
                
                container.appendChild(piece);
            }
            
            // Adjust grid for new size
            container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${size}, 1fr)`;
        }
        
        function isSolvable(puzzle, size) {
            // Simplified check for solvability
            // For even-sized puzzles, the blank should be on an even row counting from bottom
            // For simplicity, we'll just ensure the inversion count is even
            let inversions = 0;
            
            for (let i = 0; i < puzzle.length - 1; i++) {
                for (let j = i + 1; j < puzzle.length; j++) {
                    if (puzzle[i] > puzzle[j] && puzzle[i] !== 0 && puzzle[j] !== 0) {
                        inversions++;
                    }
                }
            }
            
            if (size % 2 === 1) {
                return inversions % 2 === 0;
            } else {
                const blankRow = Math.floor(puzzle.indexOf(0) / size);
                return (inversions + blankRow) % 2 === 1;
            }
        }
        
        function isSolved(container, size) {
            const pieces = Array.from(container.children);
            for (let i = 0; i < size * size - 1; i++) {
                if (parseInt(pieces[i].dataset.value) !== i + 1) {
                    return false;
                }
            }
            return pieces[size * size - 1].dataset.value === '0';
        }
    </script>
</body>
</html>
